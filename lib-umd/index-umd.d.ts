import * as common from "./common";
import * as OneByOne from "./OneByOne";
import * as UrlParse from "./urlParse";
import * as coordinate from "./coordinate";
import * as numberCalc from "./numberCalc";
declare const utils: {
    strip(num: number, precision?: number): number;
    getNumberLenAfterDot(num: string | number): number;
    NumberCalc: typeof numberCalc.NumberCalc;
    isPointInPath(point: coordinate.Point, path: coordinate.Point[]): boolean;
    getDistance(origin: coordinate.Point, target: coordinate.Point): number;
    getAngle(origin: coordinate.Point, target: coordinate.Point, direct?: coordinate.Direct): number;
    getRotatePoint(center: coordinate.Point, radius: number, rotate: number): coordinate.Point;
    twoBezier(t: number, startPos: coordinate.Point, endPos: coordinate.Point, controlPoint: coordinate.Point): coordinate.Point;
    Direct: typeof coordinate.Direct;
    createArray({ start, end, len, fill }: {
        start?: number | undefined;
        end?: number | undefined;
        len?: number | undefined;
        fill?: ((item: number, index: number) => any) | undefined;
    }): any[];
    createArray({ start, end, len, fill }: {
        start?: number | undefined;
        end?: number | undefined;
        len?: number | undefined;
        fill?: any;
    }): any[];
    forEach<T>(callbackfn: (value: T, index: number, array: ArrayLike<T>) => any, thisArg?: ArrayLike<T> | Iterable<T> | undefined): void;
    from<T_1, U>(iterable: Iterable<T_1> | ArrayLike<T_1>, mapFn?: ((v: T_1, k: number) => U) | undefined): U[];
    filter<T_2>(callbackfn: (value: T_2, index: number, array: ArrayLike<T_2>) => boolean, thisArg?: ArrayLike<T_2> | undefined): T_2[];
    includes<T_3>(thisArg: ArrayLike<T_3>, searchElement: (v: T_3, index: number, arr: ArrayLike<T_3>) => boolean, fromIndex?: number | undefined): boolean;
    includes<T_4>(thisArg: ArrayLike<T_4>, searchElement: T_4, fromIndex?: number | undefined): boolean;
    keys<T_5>(target: T_5): (keyof T_5)[];
    find<T_6>(predicate: (value: T_6, index: number, obj: T_6[]) => boolean, thisArg?: ArrayLike<T_6> | undefined): void | T_6;
    flat<T_7>(target: readonly T_7[], depth?: number): T_7[];
    binaryFind<T_8>(arr: T_8[], handler: (item: T_8, index: number, arr: T_8[]) => number, pcz?: number): T_8 | undefined;
    binaryFindIndex<T_9>(arr: T_9[], handler: (item: T_9, index: number, start: number, end: number) => number): number;
    cloneFunction<T_10 extends Function>(fn: T_10): T_10;
    deepClone<T_11>(target: T_11): T_11;
    deepCloneBfs<T_12>(target: T_12): T_12;
    debounce(callback: (...args: any[]) => void, delay: number): (...args: any[]) => void;
    polling(callback: (times: number) => void | Promise<any>, interval: number, immediate?: boolean): () => void;
    forEachByLen(len: number, callback: (index: number) => any): void;
    typeOf(target: any): string;
    randomNumber(): number;
    randomNumber(end: number): number;
    randomNumber(start: number, end: number): number;
    randomNumber(start: number, end: number, length: number): number[];
    randomColor(): string;
    randomColor(len: number): string[];
    getDateFromStr(date: string): Date | null;
    thousandFormat(num: string | number): string;
    getFormatStr(str: any, ...params: any[]): any;
    strPadStart(target: string, len: number, fill: string): string;
    strPadEnd(target: string, len: number, fill: string): string;
    oneByOne(words: string, delay: number, callback?: ((word: string, index: number, words: string) => false | void) | undefined): () => void;
    generateFunctionCode(argsArrayLength: number): string;
    generateFunction(obj: object, property: string, args: any[]): any;
    dateDiff(start: Date, end: Date, format?: string): string;
    getTreeMaxDeep(tree: object): number;
    getTreeNodeLen(tree: object, nodeNumber?: number): number;
    merge<T_13 extends object, U_1 extends object>(first: T_13, second: U_1): T_13 & U_1;
    deepMerge<T_14 extends object, U_2 extends object>(first: T_14, second: U_2): T_14 & U_2;
    sleep(delay: number): Promise<void>;
    createUUID(length: number): string;
    formatDate: common.formatDateInterface;
    number2Chinese: common.Number2Chinese;
    chinese2Number: common.Chinese2Number;
    removeClass(dom: any, className: string): string;
    prefixStyle(style: string): string | false;
    eventProxy(containerEl: string | HTMLElement | null, eventType: string, targetEl: string | HTMLElement, callback: (e: Event) => void): (() => void) | null;
    onceEvent(el: string | HTMLElement | Window | null | undefined, eventType: string, callback: (e: Event) => false | undefined, capture?: boolean): void;
    addDragEventListener({ el, onDown, onMove, onUp, capture }: {
        el?: string | HTMLElement | undefined;
        onDown?: ((e: MouseEvent | TouchEvent, currentXY: {
            x: number;
            y: number;
        }) => any) | undefined;
        onMove?: ((e: MouseEvent | TouchEvent, currentXY: {
            x: number;
            y: number;
        }, lastXY: {
            x: number;
            y: number;
        }, downXY: {
            x: number;
            y: number;
        }) => any) | undefined;
        onUp?: ((e: MouseEvent | TouchEvent, currentXY: {
            x: number;
            y: number;
        }, downXY: {
            x: number;
            y: number;
        }) => any) | undefined;
        capture?: {
            down?: boolean | undefined;
            up?: boolean | undefined;
            move?: boolean | undefined;
        } | undefined;
    }): () => void;
    onElResize(el: HTMLElement, handler: () => void): void;
    isDom: (target: any) => target is HTMLElement;
    addClass: (target: HTMLElement, className: string | string[]) => string;
    UrlParse: typeof UrlParse.UrlParse;
    OneByOne: typeof OneByOne.OneByOne;
    isObject(target: any): target is object;
    isArray(target: any): target is any[];
    isArrayLike(target: any): target is ArrayLike<any>;
    isString(target: any): target is string;
    isNumber(target: any): target is number;
    isFunction(target: any): target is Function;
    isBoolean(target: any): target is boolean;
    isUndefined(target: any): target is undefined;
    is(target: any, types: string | string[]): boolean;
    isPromiseLike<T_15, S>(target: S | PromiseLike<T_15>): target is PromiseLike<T_15>;
    isNaN(target: any): boolean;
    isEmptyObject(target: object): boolean;
    isEmpty(target: any): boolean;
    isEqual(a: any, b: any): boolean;
    objectIsEqual(obj1: object, obj2: object): boolean;
};
export default utils;
